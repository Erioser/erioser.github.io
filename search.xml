<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[夏 （妈妈的文字 一 ）]]></title>
    <url>%2F2019%2F06%2F26%2F02.%E5%A4%8F%2F</url>
    <content type="text"><![CDATA[写在前面的话：妈妈的文笔向来不错，带着一点点贾平凹先生的劲儿，又愿意闲暇时花点时间记录一些琐事，一字一句都像极了她的生活，读着这些句子，恍惚见觉得自己还在家乡，还在她的身边。她每每有了新的文字总是先要分享给我，以前自己总是收藏在微信中就又转头去忙活其他的事情了，都不肯及时给她一个反馈，可她还是乐此不疲的写了后发给我，想要将自己的文字第一时间分享给儿子。我自己也是喜欢写作的，私以为定是得了妈妈的文艺基因，可是却总腾不出一点儿的时间伏案写上几行，想到这就觉得羡慕妈妈现在轻松快乐的生活状态，佩服她想到就去做的脾气秉性。鉴于此，我准备将妈妈的文字整理一些发布出来，当做一个系列，标题不想配的很复杂，重要的是故事。 ​ ​ 三间房的红砖红瓦院落，方方正正，窗明几净。 ​ 时值盛夏，院子里的树荫似五把大小不一的绿伞，笼盖着小院，又与蓝天相间，斑斑驳驳，暖风袭来，犹如一副流动的画。 ​ 这几天，杏子出叶了，颜色也发生了变化，深绿变成浅黄中泛点淡绿。 ​ 地上分成不同的菜畦，高低不一，架豆、西红柿、茄子、辣椒在后排，前排是生菜、白菜。深绿、浅绿，黄绿也分深黄绿，浅黄绿。一阵风吹来，随风向摇摆，像绿色的波浪。 ​ 到了七、八月天，正是沙果成熟的时候，绿叶间露出数不清的黄沙果，个个是红脸蛋，伸手摘个甜的很，甜中略带酸味，还有香味。与它相对生长着的李子比它熟的早了些，红中透紫，紫中透红，轻咬一下满口都是汁水，伴着浓浓的香味，流到手上粘得手指都分不开，糖多呀，很甜很香！ ​ 地上的蔬菜相继熟了，自家的，肯定属于纯天然绿色的，总觉得哪里都比外地来的菜有味道，当然，最重要的是健康。 ​ 门台上摆了一排盆花，虽然都是普通的花，但也有主人对它们的爱，那些花好像也懂得报答似的，不时地冲你笑上一段时光，花开的盛，人笑的也欢。 ​ 在树荫下摆上方桌，一块瓷砖放在一个轮胎上当作简易饭桌，架上特制的铁盒，放上木炭，食材都是自制的：烤串、烤馒头片、烤辣椒，当然也少不了啤酒饮料。借着月光，伴着凉风，舒爽！这不就是农家自得之乐么？爱之深矣，言不足以表。]]></content>
      <categories>
        <category>字里行间</category>
      </categories>
      <tags>
        <tag>散文</tag>
        <tag>Text</tag>
        <tag>妈妈的文字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目前端优化方案]]></title>
    <url>%2F2019%2F06%2F24%2F01.Vue%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[经过对项目结构 / 开发方式 / 技术架构的研究，再次提出部分可以优化的点。 刚加入新公司之后，在学习来新公司的开发技术之后，就迫不及待的想要将自己过往的开发方式和技巧融合到现在的项目中，下面是针对目前项目的中一些技术点的改进思路 此方案主要由如下几点组成： 代码编写规范 Api层抽离 Request工具更高效封装 路由分离配置方案 目录结构整理 数据请求优化 Mock数据配置 方案在不断的编写过程中，其他内容还需大家共同努力发现，整理。 代码编写规范 良好的代码编写规范可以大幅度提高项目开发效率，增加代码的可读性/可维护性/可测试性，减少开发/重构等场景的复杂耗时程度。 代码规范可以划分为构建规范/编写规范等方面，例如项目结构的搭建，说明文档的维护/模块的构建与命名/代码中注释与业务代码编写方式等方面都应该考虑到并设立统一的/较优的规则来进行约束，下面就进行简单说明： 项目结构重构项目结构构建过程中，应该不断维护《目录结构说明文档》，并且建立项目结构版本，如：1.0.0，并且应该标注如下几点： 结构中新建与改动过程的动作说明 项目结构版本信息 目录与模块文件命名根据目前已经处于开发过程中的项目，整理部分规则如下： 一般目录命名采用lowercase方式，，目录由多个单词组件则利用”-“连接，如： router, store, components, store/modules, utils/dygraph-plugin views中路由视图目录采用大驼峰形式命名，如： views/Algorithms views/Events views/Monitor 工具模块， 基础业务模块文件采用lowercase方式，目录由多个单词组件则利用”-“连接，如： bin/babel-external-helpers.js (babel中的命名方式) store/modules/event.js 组件命名采用大驼峰方式命名，如： AlgorithmsCenter.vue AlgorithmsDdetail.vue 具体命名方式可以参考Vue.js风格指南 。 代码编写规范代码编写过程中应遵守基本的开发规范准则，在这里只是给出部分建议。 BEM（Block-Element-Modifier）结构命名方式 HTML编写DOM结构并标时尽量遵守BEM命名方式，具体请参考文献：BEM–前端命名规范介绍，BEM —— 源自Yandex的CSS 命名方法论。 注意：没必要真的在每个地方都用上它，当某个节点不属于任何一个BEM范畴的时候，按照常规命名方式就可以。 OOCSS（Object Oriented CSS）编写方式 OOCSS（面向对象CSS编写）并不是什么新奇的技术，它想表明的其实就是我们可以将样式与固定的dom解耦，将一个或多个细小的css样式添加到需要它们的dom节点身上，目的其实还是为了提高代码的复用率，并且代码可读性也会有很大的提高，在项目中特别推荐使用BEM + OOCSS的开发方式，网上有很多结合使用指南，这里给大家提供一个非常简洁的CSS的组件化方案：OOCSS + BEM。 Javascript规范可以参考Eslint中更多详细的规则，Google Javascript规范也是不错的选择，比如： 1. 拒绝var 2. 使用空格代替tab 3. 优先使用箭头函数 4. 使用模版字符串代替连接字符串 5. ...这里提供给大家来自阿里的Kissy 最佳编码实践。 注释方式 对于注释其实应该更加看重，好的注释可以大幅度提高代码的可读性。 HTML文档中应该对页面每一个Block的开始和结束进行注释说明，单独的Element也要标明，例如： 123456789101112131415161718192021222324&lt;div class=&quot;events-center&quot;&gt; &lt;!-- 头部图表显示 start --&gt; &lt;div class=&quot;top-chart&quot;&gt; &lt;stacked-bar-chart :counts=&quot;eventCounts&quot; :color=&quot;eventColor&quot; @click=&quot;handleBarClick&quot;&gt;&lt;/stacked-bar-chart&gt; &lt;/div&gt; &lt;!-- 头部图表显示 end --&gt; &lt;!-- 搜索与操作模块 start --&gt; &lt;div class=&quot;toolbar horizontal background&quot;&gt; &lt;!-- 搜索功能组件 --&gt; &lt;cv-search :placeholder=&quot;helloWord&quot; v-model=&quot;query&quot;&gt;&lt;/cv-search&gt; &lt;!-- 设置按钮 --&gt; &lt;div v-if=&quot;!filterToggle&quot; @click=&quot;openFilter&quot; class=&quot;filter-icon&quot;&gt;&lt;icon-settings /&gt;&lt;/div&gt; &lt;!-- 模式切换按钮 --&gt; &lt;div v-if=&quot;!filterToggle&quot; @click=&quot;switchMode&quot; class=&quot;filter-icon&quot;&gt;&lt;icon-mode /&gt;&lt;/div&gt; &lt;!-- 操作按钮组 start--&gt; &lt;cv-button v-if=&quot;filterToggle&quot; kind=&quot;secondary&quot; @click=&quot;resetFilter&quot;&gt;重置&lt;/cv-button&gt; &lt;cv-button v-if=&quot;filterToggle&quot; kind=&quot;secondary&quot; @click=&quot;cancelFilter&quot;&gt;取消&lt;/cv-button&gt; &lt;cv-button v-if=&quot;filterToggle&quot; @click=&quot;confirmFilter&quot;&gt;确认&lt;/cv-button&gt; &lt;!-- 操作按钮组 end--&gt; &lt;/div&gt; &lt;!-- 搜索与操作模块 end --&gt;&lt;/div&gt; CSS中也应该根据所编写的代码划分结构片段后注释，尽可能使用多行注释方式（/**/），如下： 123456789101112131415161718/* css reset start*/*&#123; box-sizing: border-box&#125;body &#123; margin: 0; background-color: #FFF; font-family: MicrosoftYaHei, PingFangSC, Helvetica, Arial, sans-serif, &quot;宋体&quot;;&#125;// .../* elemnt-ui table 样式重置 */.el-table tr &#123; background-color: #f3f3f3; cursor: pointer;&#125;// ... JS中的注释希望能采用JSDoc推荐的方式，这样更有利于开发到某一阶段时，利用JSDoc工具直接生成关于该JS模块的文档，具体可以参考文档：JSDoc在线文档，JSDoc中文文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 为了演示JSDoc的示例模块. * @module utils/jsdoc * @see module:main.js */ /** 暴露 name */export const name = &apos;mixer&apos;;/** * 错误处理方法. * @param &#123;object&#125; self - 调用方法的vue实例. * @param &#123;object&#125; error - 错误对象. * @param &#123;string&#125; errorMessage - 出错提醒信息. * @return &#123;string&#125; 处理后的错误信息文本. * @example * errorTip(this, e, &apos;登陆失败&apos;) */export function errorTip (self, error, errorMessage) &#123; // 处理后的错误文本信息 let message = translate(error.message || error.msg || &apos;出错了，请重试&apos;) console.log(error, message) // 调用vue实例的消息提示方法 self.$message(&#123; type: &apos;error&apos;, message: errorMessage || message, center: true, duration: (error.message &amp;&amp; error.message.indexOf(&apos;Network Error&apos;) !== -1) ? 8000 : 3000 &#125;) return message&#125;/** * 错误文本信息处理方法. * @param &#123;string&#125; message - 原始的error对象中的报错信息. * @return &#123;string&#125; 处理后的错误信息. */function translate (message) &#123; if (message.indexOf(&apos;timeout&apos;) !== -1) &#123; return &apos;请求超时&apos; &#125; else if (message.indexOf(&apos;Network Error&apos;) !== -1) &#123; return &apos;网络错误&apos; &#125; else &#123; return &apos;出错了，请重试&apos; &#125;&#125; 生成文档的方式： 下载jsdoc-to-markdown 可以将文档输出为markdown 1npm install --save-dev jsdoc-to-markdown 配置scripts 12345&#123; &quot;scripts&quot;: &#123; &quot;docs&quot;: &quot;jsdoc2md lib/*.js &gt; api.md&quot; &#125;&#125; 执行任务 1npm run docs 即可将lib下所有的js文件根据jsdoc规范生成到api.md中。 Request工具高效封装针对axios进行了更高效的封装，比如设置了拦截器，在数据请求回来后就可以根据请求结果的状态进行失败处理等等。 config/axios.config.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * axios 配置模块 * @module config/axios.config * @see utils/request*/import qs from &apos;qs&apos;;/** * axios具体配置对象 * @description 包含了基础路径/请求前后对数据对处理，自定义请求头的设置等 */const axiosConfig = &#123; baseURL: process.env.RESTAPI_PREFIX, // 请求前的数据处理 transformRequest: [function (data) &#123; return data; &#125;], // 请求后的数据处理 transformResponse: [function (data) &#123; return data; &#125;], // 自定义的请求头 headers: &#123; &apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;, &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;, // 查询对象序列化函数 paramsSerializer: function (params) &#123; return qs.stringify(params); &#125;, // 超时设置s timeout: 10000, // 跨域是否带Token 项目中加上会出错 // withCredentials: true, // 自定义请求处理 // adapter: function(resolve, reject, config) &#123;&#125;, // 响应的数据格式 json / blob /document /arraybuffer / text / stream responseType: &apos;json&apos;, // xsrf 设置 xsrfCookieName: &apos;XSRF-TOKEN&apos;, xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // 下传和下载进度回调 onUploadProgress: function (progressEvent) &#123; Math.round(progressEvent.loaded * 100 / progressEvent.total); &#125;, onDownloadProgress: function (progressEvent) &#123; Math.round(progressEvent.loaded * 100 / progressEvent.total); &#125;, // 最多转发数，用于node.js maxRedirects: 5, // 最大响应数据大小 maxContentLength: 2000, // 自定义错误状态码范围 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; &#125;, // 用于node.js // httpAgent: new http.Agent(&#123; keepAlive: true &#125;), // httpsAgent: new https.Agent(&#123; keepAlive: true &#125;)&#125;;/** 导出配置模块 */export default axiosConfig; utils/request.js(目前使用的是restapi.js): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 业务中使用的ajax请求工具模块 * @module utils/request * @see main.js */import axios from &apos;axios&apos;;import config from &apos;../config/axios.config&apos;;import qs from &apos;querystring&apos;import Vue from &apos;vue&apos;import &#123; errorTip &#125; from &apos;utils/common&apos;// 用来调用errorTip的vue实例const vueInstance = new Vue()// 构建得的请求对象const request = axios.create(config);// 返回状态判断(添加响应拦截器)request.interceptors.response.use( res =&gt; &#123; // 如果数据请求失败 if ( res.data.code &gt; 300 ) &#123; errorTip(vueInstance, res.data) return Promise.reject(res.data); &#125; return res.data.data; &#125;, error =&gt; &#123; return Promise.reject(error); &#125;);request.interceptors.request.use((config) =&gt; &#123; let allowMethods = [&apos;post&apos;]; if (allowMethods.indexOf(config.method) !== -1) &#123; config.headers[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; config.data = qs.stringify(config.data); &#125; return config;&#125;, (error) =&gt; &#123; return Promise.reject(error);&#125;);// 对axios的实例重新封装成一个plugin ,方便 Vue.use(xxxx)export default request; Api抽离在src开发目录中建立api目录结构，在其中可以集中构建所有请求动作的模块，以便调用。 api/index.js: 12345678910111213141516171819202122232425/** * api接口调用维护模块 * @module api * @see main */ import request from &apos;utils/request&apos; import Vue from &apos;vue&apos; import &#123; errorTip &#125; from &apos;utils/common&apos; // 用来调用errorTip的vue实例 const vueInstance = new Vue() /** * 分页获取算法列表 * @param &#123;Object&#125; [p] pageInfo 页码相关信息 * @param &#123;number&#125; [p.page] page 页数 * @param &#123;number&#125; [p.size] size 每页数据个数 * @param &#123;string&#125; [p.labels] labels 标签 * @param &#123;string&#125; [p.query] query 查询条件 * @return &#123;Promise&#125; request 请求动作promise */ export let apiGetList = (&#123;page = 1, size = 10, labels = &apos;anomaly&apos;, query = &apos;&apos;&#125; = &#123;&#125;) =&gt; &#123; return request.get(`/algorithm?page=$&#123;page&#125;&amp;labels=$&#123;labels&#125;&amp;size=$&#123;size&#125;&amp;query=$&#123;query&#125;`).catch(error =&gt; errorTip(vueInstance, error)) &#125; 数据请求动作优化利用async await对请求作出优化处理，在需要调用请求的地方利用async/await来规避回调函数的嵌套。 store/modules/setting.js: 123456789101112131415161718192021222324import &#123; apiGetList &#125; from &apos;api&apos;// ...actions: &#123; // 分页获取算法列表 当前写法 getList: (&#123; commit &#125;, &#123;page = 1, size = 10, labels = &apos;anomaly&apos;, query = &apos;&apos;&#125; = &#123;&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; restapi.request(&#123; method: &apos;get&apos;, url: `/algorithm?page=$&#123;page&#125;&amp;labels=$&#123;labels&#125;&amp;size=$&#123;size&#125;&amp;query=$&#123;query&#125;`, success: sdata =&gt; &#123; commit(&apos;LIST_ALGORITHMS&apos;, sdata) resolve(sdata) &#125;, error: reject &#125;) &#125;) &#125;, // 分页获取算法列表 重构后写法 getListTest: async (&#123; commit &#125;, params) =&gt; &#123; let sdata = await apiGetList(params) commit(&apos;LIST_ALGORITHMS&apos;, sdata) &#125; // ...&#125; 视图中调用方式基本区别不大，不需要再做请求错误处理。 views/Algorithms/AlgorithmsCenter.vue 12345678910111213methods: &#123;...mapActions(&apos;algorithm&apos;, [ &apos;getList&apos;, &apos;getListTest&apos;, &apos;getCount&apos;]),// ...getAlgorithmsList (&#123;start = 1, length = 10&#125; = &#123;&#125;) &#123; // this.getList(&#123;page: Math.ceil(start / length), size: length, labels: this.algoType&#125;).catch(error =&gt; errorTip(this, error)) // 当前调用方式 this.getListTest(&#123;page: Math.ceil(start / length), size: length, labels: this.algoType&#125;)// 重构后调用方式&#125;// ...&#125; Mock数据搭建 mock数据的搭建有利于在前后端开发进度不同步的情况下进行模拟数据请求，就可以根据请求完成前端的交互逻辑，合理的配置可以在有真实接口后稍作更改就可以调用线上真实接口，处理手法更平滑。 Mock的搭建有很多种方式，在这里推荐使用json-server的使用方式，本质就是利用json-server快捷的启动一个mock服务器，然后在config/index/dev/proxyTable中代理请求到mock服务器即可。 具体配置过程可以参考 json-server配置详解 其实EasyMock这个网站也提供来便利的mock数据的方式，不再需要自己去搭建mock环境，简直是非常棒了]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Technology</tag>
        <tag>优化</tag>
      </tags>
  </entry>
</search>
